@startuml
class Content.Boulder extends Content.Substance implements Interfaces.Exists {
+Boulder(Adjectiveable adj)
+void toBeDescrition()
+void toBe(Boolean negative, int time)
}


class Content.Branch extends Content.Substance {
+Branch(Adjectiveable adj)
}


class Content.Clot extends Content.Substance {
+Clot(Adjectiveable adj)
}


class Content.Conture extends Content.Substance implements Interfaces.Exists, Interfaces.BeDefined {
+Conture()
+void contureOf(Substance substance, STATUS status)
+void toBe(Boolean negative, int time)
+void toBeDefined()
}


class Content.Figure extends Content.Substance implements Interfaces.Exists {
+Figure(Adjectiveable adj)
+String toString()
+void toBe(Boolean negative, int time)
}


class Content.Machine extends Content.Substance {
+static final String[] machines = new String[]

+Machine()
+void named(int n)
+void thisMachine()
+void withHelp()
+String toString()
}


class Content.Monument extends Content.Substance implements Interfaces.Exists {
+Monument()
+Monument(STATUS status)
+void toBePublished(TIME time)
+void toBeBorn()
+void toBe(Boolean negative, int time)
}


class Content.Music extends Content.Substance {
+Music()
+String faded()
}


class Content.Notch extends Content.Substance {
+Notch()
+void toBeMade(Machine machine, PLACE place)
}


class Content.Specie extends Content.Substance implements Interfaces.WhatInside {
+Specie()
+void whatInside()
}


class Content.Stage extends Content.Substance {
+Stage(STATUS status)
+void await()
}


abstract class Content.Substance {
-final String name
-Adjectiveable adj
-STATUS status
+Substance(String name)
+Substance(String name, STATUS status)
+Substance(String name, Adjectiveable adj)
+String getName()
+Adjectiveable getAdj()
+STATUS getStatus()
+void setStatus(STATUS status)
+boolean equals(Object obj)
}


class Content.Surface extends Content.Substance {
+Surface(Adjectiveable adj)
}


class Content.Work extends Content.Substance {
-STATUS[] statuses
+Work( STATUS[] status)
+STATUS[] getStatuses()
+void setStatuses(STATUS[] statuses)
+void finalStage(Stage stage)
+String toString()
}


abstract class Emotional.Emotion {
-final String name
-STATUS[] status
+Emotion(String name)
+Emotion(String name, STATUS[] status)
+String getName()
+String toString()
+STATUS[] getStatus()
+void setStatus(STATUS[] status)
}


class Emotional.Fear extends Emotional.Emotion {
+Fear()
+Fear(STATUS[] status)
+void change(PLACE place, TIME time, Emotion emotion)
}
Emotional.Fear -down[#AAA]-o Enums.STATUS

class Emotional.Grimace extends Emotional.Emotion {
+Grimace(STATUS[] status)
}

enum Enums.PLACE {
SQUARE ("вся площадь"),
LENINGRAD ("ленинградский"),
SILENCE ("В наступившей тишине"),
FACE ("на его лице"),
NOWHERE ("нигде"),
STONE (" на камне "),
NOPLACE ("")
-final String place
PLACE (String place)
+String getPlace()
+String toString()
}


enum Enums.SPECIAL {
NECESSARY ("Необходимо"),
ASTHEYSAY (", как говорится, "),
FORTHIS ("Для этого"),
THEN ("Затем"),
SOMETHING ("Что-то вроде"),
ANDSOON ("И так далее"),
INGENERAL ("В общем"),
OFC ("разумеется"),
ABSOLUTELY ("Абсолютно точно"),
WTF ("Что же произошло?"),
SOCALLED (", так называемые"),
LIKE ("что-то вроде")
-final String special
SPECIAL (String special)
+String getSpecial()
+String toString()
}


enum Enums.STATUS {
NORMAL (""),
INDIFFERENCE ("безразличия"),
HOPELESSNESS ("безысходности"),
UNHAPPY ("Несчастный"),
BROKEN ("бракованный"),
FUTURE ("будущего"),
FINAL ("завершающий"),
ACCURACY ("филигранная"),
RESPONSIBLE ("ответственная"),
DIFFERENT ("иной")
-final String status
STATUS (String status)
+String getStatus()
+String toString()
}


enum Enums.TIME {
MINUTE ("Через минуту"),
MORNING ("Наутро"),
OVERNIGHT ("За ночь"),
GRADUALLY ("постепенно"),
EVERYDAY ("ежедневно"),
OPPORTUNITY ("при каждом удобном случае"),
OCCASIONALLY ("изредка"),
HASTILY ("поспешно"),
AGAIN ("снова"),
LATER ("Потом"),
AFTER ("Затем")
-final String time
TIME (String time)
+String getTime()
+String toString()
}


class Exeptions.OutOfMachines extends Exception {
+OutOfMachines()
}


interface Interfaces.Adjectiveable {
+void beAdjective()
}


interface Interfaces.BeDefined {
+void toBeDefined()
}


interface Interfaces.BeDrunkard {
+Boolean beDrunkard()
+void drink()
}


interface Interfaces.BeDrunkardMaster extends Interfaces.BeDrunkard, Interfaces.BeMaster {
+boolean beDrunkardMaster()
}


interface Interfaces.BeMaster {
+Boolean beMaster()
}


interface Interfaces.Exists {
void toBe(Boolean negative, int time)
}


interface Interfaces.WhatInside {
+void whatInside()
}


class Main {
+static void main(String[] args)
}
Main -down[#AAA]-o People.Lenin
Main -down[#AAA]-o People.Lihachev
Main -down[#AAA]-o People.ViktorC
Main -down[#AAA]-o People.ViktorD
Main -down[#AAA]-o Materials.Cap
Main -down[#AAA]-o People.Me
Main -down[#AAA]-o People.NoName
Main -down[#AAA]-o Content.Music
Main -down[#AAA]-o People.Human
Main -down[#AAA]-o Professions.Sculptor
'!>10 Main -down[#AAA]-o Content.Monument
'!>10 Main -down[#AAA]-o Materials.Gypsum
'!>10 Main -down[#AAA]-o Materials.Marble
'!>10 Main -down[#AAA]-o Content.Boulder
'!>10 Main -down[#AAA]-o Emotional.Grimace
'!>10 Main -down[#AAA]-o Enums.STATUS
'!>10 Main -down[#AAA]-o Emotional.Fear
'!>10 Main -down[#AAA]-o Professions.Chief
'!>10 Main -down[#AAA]-o Professions.Official
'!>10 Main -down[#AAA]-o Content.Monument
'!>10 Main -down[#AAA]-o Content.Figure
'!>10 Main -down[#AAA]-o Materials.Clay
'!>10 Main -down[#AAA]-o Professions.Molder
'!>10 Main -down[#AAA]-o Professions.StoneCutter
'!>10 Main -down[#AAA]-o Content.Figure
'!>10 Main -down[#AAA]-o Content.Machine
'!>10 Main -down[#AAA]-o Content.Notch
'!>10 Main -down[#AAA]-o Content.Conture
'!>10 Main -down[#AAA]-o Content.Work
'!>10 Main -down[#AAA]-o Enums.STATUS
'!>10 Main -down[#AAA]-o Materials.Marble
'!>10 Main -down[#AAA]-o Materials.Cap
'!>10 Main -down[#AAA]-o Materials.Cap
'!>10 Main -down[#AAA]-o Materials.Cap
'!>10 Main -down[#AAA]-o Materials.Cap
'!>10 Main -down[#AAA]-o Materials.Cap
'!>10 Main -down[#AAA]-o Materials.Cap
'!>10 Main -down[#AAA]-o Materials.Cloth
'!>10 Main -down[#AAA]-o Content.Stage
'!>10 Main -down[#AAA]-o Content.Surface
'!>10 Main -down[#AAA]-o Content.Branch
'!>10 Main -down[#AAA]-o Materials.Wood
'!>10 Main -down[#AAA]-o Content.Clot
'!>10 Main -down[#AAA]-o Materials.Facture
'!>10 Main -down[#AAA]-o Content.Branch
'!>10 Main -down[#AAA]-o Materials.Wood
'!>10 Main -down[#AAA]-o Content.Specie

class Materials.Materials.Cap extends Materials {
+Cap()
+static void getCap(byte amount)
+void removeCap(TIME time)
}


class Materials.Materials.Clay extends Materials implements Interfaces.Adjectiveable {
+Clay()
+void beAdjective()
}


class Materials.Materials.Cloth extends Materials {
-String color
+Cloth()
+Cloth(String color)
+String getColor()
+void setColor(String color)
+String getName()
}


class Materials.Materials.Facture extends Materials implements Interfaces.Adjectiveable {
+Facture()
+void beAdjective()
}


class Materials.Materials.Gypsum extends Materials implements Interfaces.Adjectiveable {
+Gypsum()
+void beAdjective()
}


class  Materials.Materials.Marble extends Materials implements Interfaces.Adjectiveable, Interfaces.WhatInside {
+Marble()
+void construction(Substance substance)
+void othersInside(Substance substance, Substance substance2)
+void beAdjective()
+void whatInside()
}


abstract class Materials.Materials {
-final String name
+Materials(String name)
+String getName()
}


class Materials.Wood extends Materials.Materials implements Interfaces.Adjectiveable {
+Wood()
+void beAdjective()
}


class People.Human extends People.Person {
+Human()
+void beDrunkMaster(BeDrunkardMaster dm1, BeDrunkardMaster dm2)
+void laugh(boolean negative)
}


class People.Lenin extends People.Person {
+Lenin()
+void toSqueeze(Cap cap)
+void laugh(boolean negative)
static class Arm
}


class People.Lihachev extends People.Person implements Interfaces.BeDrunkardMaster {
-final Profession profession
+Lihachev()
+void haveFriendHelper(Person person)
+void whatProfession()
+void drinkRarely()
+void laugh(boolean negative)
+Boolean beDrunkard()
+void drink()
+Boolean beMaster()
+boolean beDrunkardMaster()
}
People.Lihachev -down[#AAA]-o Professions.Brigadier

class People.Me extends People.Person implements Interfaces.Exists {
+Me()
+void disturbed(TIME time)
+void enlisted(Profession profession)
+void count(Person[] brigada)
+void toBe(Boolean negative, int time)
+void laugh(boolean negative)
}


class People.NoName extends People.Person {
-final boolean negative = true
+NoName()
+void remove()
+void copy(Substance substance)
+void laughTimePlace(TIME time, PLACE where)
+void laughPlace(PLACE where)
+String getFirstName()
+void laugh(boolean negative)
}


abstract class People.Person {
-final String firstName
-final String secondName
-Profession[] professions
+Person(String firstName, String secondName)
+Person(String firstName, String secondName, Profession[] professions)
+Person(String firstName)
+String getFirstName()
+String getSecondName()
+Profession[] getProfessions()
+void setProfessions(Profession[] professions)
+String getFirstSecondName()
+abstract void laugh(boolean negative)
}


class People.ViktorC extends People.Person implements Interfaces.BeDrunkardMaster {
+ViktorC()
+void drinkEveryday()
+void laugh(boolean negative)
+Boolean beDrunkard()
+void drink()
+Boolean beMaster()
+boolean beDrunkardMaster()
}


class People.ViktorD extends People.Person {
+ViktorD()
+void laugh(boolean negative)
}


class Professions.Brigadier extends Professions.Profession {
+Brigadier()
}


class Professions.Chief extends Professions.Profession {
+Chief()
+void cover(Materials[] items)
static class Head
}


class Professions.Master extends Professions.Profession {
+Master()
}


class Professions.Molder extends Professions.Profession {
+Molder()
+void cast(Substance substance, Monument monument, Materials item2)
}


class Professions.Official extends Professions.Profession {
+Official()
+void hide(TIME time, Substance substance, Materials item)
}


abstract class Professions.Profession {
-final String name
-STATUS status
+Profession(String name)
+Profession(String name, STATUS status)
+String getName()
+STATUS getStatus()
+void setStatus(STATUS status)
}


class Professions.Sculptor extends Professions.Profession implements Interfaces.Exists {
+Sculptor(STATUS status)
+void make(Materials[] items)
+void sculptorMade(Materials[] items)
+void sculptorMade(Substance substance)
+void toBePerson(Person person)
+void toBe(Boolean negative, int time)
+String toString()
}


class Professions.StoneCutter extends Professions.Profession {
+StoneCutter()
+void beArmedWith(int machineNum)
+void constrict(Materials materials)
+void takes(int[] instruments)
+void incorrectMove()
+void takeOn(TIME time)
+void handle(Substance substance)
}
Professions.StoneCutter -down[#AAA]-o Exeptions.OutOfMachines

class StringMethods.StringMeth {
+static String capitalize(String str)
+static String dot(String str)
+static String dotn(String str)
}
@enduml